
service: hello-world-appsync
frameworkVersion: '3'

plugins:
  - serverless-appsync-plugin
  # - serverless-pseudo-parameters
  # - serverless-iam-roles-per-function

provider:
  name: aws
  region: us-west-2
  runtime: nodejs18.x
  stage: ${opt:stage, "dev"}
  stackName: ${self:service}-${self:provider.stage}-stack
  # ðŸ‘‡ Add IAM role permissions here
  iam:
    role:
      statements:
        - Effect: "Allow"
          Action:
            - "dynamodb:PutItem"
            - "dynamodb:UpdateItem"
            - "dynamodb:DeleteItem"
            - "dynamodb:GetItem"
            - "dynamodb:Scan"
          Resource: "arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.TODO_TABLE}"
        # - arn:aws:dynamodb:us-west-2:590184006483:table/todo-table

# LAMBDA FUNCTION CREATION
functions:
  helloLambda:
    handler: handler.hello
  amardeep:
    handler: amardeephandler.xyz
  praveen:
    handler: praveenhandler.klm
  PraveenMutation: 
    handler: praveenMutationhandler.abc
    environment:
      TODO_TABLE_NAME: !Ref TodoTable
  GetBook:
    handler: getBookhandler.getBookNa

custom:
  TODO_TABLE: todo-table

appSync:
  name: ${self:service}-api
  authentication:
    type: API_KEY
  apiKeys:
  - name: Default
    expiresAfter: 30d  # key will be valid for 30 days

  schema: schema.graphql
# query/mutation ->resolver-> pipelinFunctions (CODE) -> datasources(LAMBDA)
  resolvers:
    Query.hello:
      functions:
        - helloPipeline
    Query.amardeepfn:
      functions:
        - amardeepfunction
    Query.praveenfx:
      functions:
        - praveenfunction
    Mutation.praveenMutation:
      functions:
        - praveenfunctionMutation
    Query.getBook:
      functions:
        - getBookfx
    # Mutation.addBook:
    #   functions:
    #     - mutateBookfx

  dataSources:
    helloDataSource:
      type: AWS_LAMBDA
      name: helloDataSource
      config:
        # FIXED: use the correct CloudFormation resource name
        functionArn: !GetAtt HelloLambdaLambdaFunction.Arn
        #helloLambda + LambdaFunction.Arn,  arn:aws:lambda:us-west-2:590184006483:function:hello-world-appsync-dev-helloLambda
    amardeepDataSource:
      type: AWS_LAMBDA
      name: amardeepDataSource
      config:
        # FIXED: use the correct CloudFormation resource name
        functionArn: !GetAtt AmardeepLambdaFunction.Arn
    praveenDataSource:
      type: AWS_LAMBDA
      name: praveenDataSource
      config:
        functionArn: !GetAtt PraveenLambdaFunction.Arn
    praveenMutationDataSource:
      type: AWS_LAMBDA
      name: praveenMutationDataSource
      config:
        functionArn: !GetAtt PraveenMutationLambdaFunction.Arn
    getBookDataSource:
      type: AWS_LAMBDA
      name: getBookDataSource
      config:
        functionArn: !GetAtt GetBookLambdaFunction.Arn


  pipelineFunctions:
    helloPipeline:
      dataSource: helloDataSource
      code: ./resolvers/lambdaResolver.js
    amardeepfunction:
      dataSource: amardeepDataSource
      code: ./resolvers/amardeepResolver.js
    praveenfunction:
      dataSource: praveenDataSource
      code: ./resolvers/praveenResolver.js
    praveenfunctionMutation:
      dataSource: praveenMutationDataSource
      code: ./resolvers/praveenMutationResolver.js
    getBookfx:
      dataSource: getBookDataSource
      code: ./resolvers/getBookResolver.js

resources:
  Resources:
    TodoTable:
      Type: "AWS::DynamoDB::Table"
      Properties:
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        BillingMode: PAY_PER_REQUEST
        TableName: ${self:custom.TODO_TABLE}


# service: appsync-lambda-demo
# frameworkVersion: '3'

# plugins:
#   - serverless-appsync-plugin
#   # - serverless-iam-roles-per-function

# provider:
#   name: aws
#   region: us-east-2
#   runtime: nodejs18.x
#   stage: ${opt:stage, "dev"}
#   stackName: ${self:service}-${self:provider.stage}-stack

# appSync:
#   name: my-appSync-demo-api
#   authentication:
#     type: API_KEY
#   resolvers:
#     Query.hello:
#       dataSource: my-table
#   dataSources:
#     my-table:
#       type: AMAZON_DYNAMODB
#       config:
#         tableName: ${sls:stage}-data

# # appSync:
# #   name: ${self:service}-api
# #   authentication:
# #     type: API_KEY

# #   # resolvers:
# #   #   Mutation.startAsyncProcess:
# #   #     functions:
# #   #       - startAsyncProcessLambda

# #   resolvers:
# #     Query.hello:
# #       functions:
# #         - hello

# #   dataSources:
# #     startAsyncProcessDataSource:
# #       type: AWS_LAMBDA
# #       name: startAsyncProcessDataSource
# #       # config:
# #       #   functionArn: !GetAtt StartAsyncProcessLambdaFunction.Arn

# #   pipelineFunctions:
# #     hello:
# #       dataSource: startAsyncProcessDataSource
# #       code: "./resolvers/lambdaResolver.js"

# # resources:
# #   Resources:
# #     acoAsyncTablePoc:
# #       Type: AWS::DynamoDB::Table
# #       Properties:
# #         TableName: aco-async-table-poc-${self:provider.stage}
# #         AttributeDefinitions:
# #           - AttributeName: transactionId
# #             AttributeType: S
# #         KeySchema:
# #           - AttributeName: transactionId
# #             KeyType: HASH
# #         BillingMode: PAY_PER_REQUEST

# #     # transactionsDLQ:
# #     #   Type: AWS::SQS::Queue
# #     #   Properties:
# #     #     QueueName: transactionsDLQ-${self:provider.stage}
# #     #     VisibilityTimeout: 90

# #     # transactionsQueue:
# #     #   Type: AWS::SQS::Queue
# #     #   Properties:
# #     #     QueueName: transactionsQueue-${self:provider.stage}
# #     #     VisibilityTimeout: 90
# #     #     RedrivePolicy:
# #     #       deadLetterTargetArn: !GetAtt transactionsDLQ.Arn
# #     #       maxReceiveCount: 5

# functions:
#   hello:
#     handler: index.handler
#     # environment:
#     #   TRANSACTIONS_TABLE_NAME: !Ref acoAsyncTablePoc
#     #   REGION: ${self:provider.region}
#     # iamRoleStatements:
#     #   - Effect: Allow
#     #     Action:
#     #       - dynamodb:UpdateItem
#     #     Resource: !GetAtt acoAsyncTablePoc.Arn
#     # events:
#     #   - sqs:
#     #       arn: !GetAtt transactionsQueue.Arn
#     #       batchSize: 1
#     # timeout: 60

#   # startAsyncProcess:
#   #   handler: src/start-async-process/index.handler
#   #   environment:
#   #     TRANSACTIONS_TABLE_NAME: !Ref acoAsyncTablePoc
#   #     TRANSACTIONS_QUEUE_URL: !Ref transactionsQueue
#   #     REGION: ${self:provider.region}
#   #   iamRoleStatements:
#   #     - Effect: Allow
#   #       Action:
#   #         - dynamodb:PutItem
#   #       Resource: !GetAtt acoAsyncTablePoc.Arn
#   #     - Effect: Allow
#   #       Action:
#   #         - sqs:SendMessage
#   #       Resource: !GetAtt transactionsQueue.Arn
#   #   timeout: 60



# # # Welcome to Serverless!
# # #
# # # This file is the main config file for your service.
# # # It's very minimal at this point and uses default values.
# # # You can always add more config options for more control.
# # # We've included some commented out config examples here.
# # # Just uncomment any of them to get that config option.
# # #
# # # For full config options, check the docs:
# # #    docs.serverless.com
# # #
# # # Happy Coding!

# # service: appsync-lambda-demo
# # # app and org for use with dashboard.serverless.com
# # #app: your-app-name
# # #org: your-org-name

# # # You can pin your service to only deploy with a specific Serverless version
# # # Check out our docs for more details
# # frameworkVersion: "3"

# # provider:
# #   name: aws
# #   runtime: nodejs18.x

# # # you can overwrite defaults here
# # #  stage: dev
# # #  region: us-east-1

# # # you can add statements to the Lambda function's IAM Role here
# # #  iam:
# # #    role:
# # #      statements:
# # #        - Effect: "Allow"
# # #          Action:
# # #            - "s3:ListBucket"
# # #          Resource: { "Fn::Join" : ["", ["arn:aws:s3:::", { "Ref" : "ServerlessDeploymentBucket" } ] ]  }
# # #        - Effect: "Allow"
# # #          Action:
# # #            - "s3:PutObject"
# # #          Resource:
# # #            Fn::Join:
# # #              - ""
# # #              - - "arn:aws:s3:::"
# # #                - "Ref" : "ServerlessDeploymentBucket"
# # #                - "/*"

# # # you can define service wide environment variables here
# # #  environment:
# # #    variable1: value1

# # # you can add packaging information here
# # #package:
# # #  patterns:
# # #    - '!exclude-me.js'
# # #    - '!exclude-me-dir/**'
# # #    - include-me.js
# # #    - include-me-dir/**

# # functions:
# #   hello:
# #     handler: handler.hello
# # #    The following are a few example events you can configure
# # #    NOTE: Please make sure to change your handler code to work with those events
# # #    Check the event documentation for details
# # #    events:
# # #      - httpApi:
# # #          path: /users/create
# # #          method: get
# # #      - websocket: $connect
# # #      - s3: ${env:BUCKET}
# # #      - schedule: rate(10 minutes)
# # #      - sns: greeter-topic
# # #      - stream: arn:aws:dynamodb:region:XXXXXX:table/foo/stream/1970-01-01T00:00:00.000
# # #      - alexaSkill: amzn1.ask.skill.xx-xx-xx-xx
# # #      - alexaSmartHome: amzn1.ask.skill.xx-xx-xx-xx
# # #      - iot:
# # #          sql: "SELECT * FROM 'some_topic'"
# # #      - cloudwatchEvent:
# # #          event:
# # #            source:
# # #              - "aws.ec2"
# # #            detail-type:
# # #              - "EC2 Instance State-change Notification"
# # #            detail:
# # #              state:
# # #                - pending
# # #      - cloudwatchLog: '/aws/lambda/hello'
# # #      - cognitoUserPool:
# # #          pool: MyUserPool
# # #          trigger: PreSignUp
# # #      - alb:
# # #          listenerArn: arn:aws:elasticloadbalancing:us-east-1:XXXXXX:listener/app/my-load-balancer/50dc6c495c0c9188/
# # #          priority: 1
# # #          conditions:
# # #            host: example.com
# # #            path: /hello

# # #    Define function environment variables here
# # #    environment:
# # #      variable2: value2

# # # you can add CloudFormation resource templates here
# # #resources:
# # #  Resources:
# # #    NewResource:
# # #      Type: AWS::S3::Bucket
# # #      Properties:
# # #        BucketName: my-new-bucket
# # #  Outputs:
# # #     NewOutput:
# # #       Description: "Description for the output"
# # #       Value: "Some output value"
